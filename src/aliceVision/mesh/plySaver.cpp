// This file is part of the AliceVision project.
// This Source Code Form is subject to the terms of the Mozilla Public License,
// v. 2.0. If a copy of the MPL was not distributed with this file,
// You can obtain one at https://mozilla.org/MPL/2.0/.

#include "plySaver.hpp"

int savePLY(std::string plyFileName, Mesh* me, bool diffuse)
{
    // printf("Writing to file %s \n",plyFileName.c_str());

    FILE* plyf = nullptr;

    bool dobinary = true;

    if(dobinary)
    {
        plyf = fopen(plyFileName.c_str(), "wb");
    }
    else
    {
        plyf = fopen(plyFileName.c_str(), "wb");
    }

    if(plyf == nullptr)
    {
        printf("Could not open output ply file %s\n", plyFileName.c_str());
        return -1;
    }

    fprintf(plyf, "ply%c", 10);
    if(dobinary)
    {
        fprintf(plyf, "format binary_little_endian 1.0%c", 10);
    }
    else
    {
        fprintf(plyf, "format ascii 1.0%c", 10);
    }
    fprintf(plyf, "comment Generated by multiRecon ( http://cmp.felk.cvut.cz/~jancom1 )%c", 10);
    fprintf(plyf, "element vertex %d%c", me->pts->size(), 10);
    fprintf(plyf, "property float x%c", 10);
    fprintf(plyf, "property float y%c", 10);
    fprintf(plyf, "property float z%c", 10);
    if(diffuse)
    {
        fprintf(plyf, "property uchar diffuse_red%c", 10);
        fprintf(plyf, "property uchar diffuse_green%c", 10);
        fprintf(plyf, "property uchar diffuse_blue%c", 10);
    }
    else
    {
        fprintf(plyf, "property uchar red%c", 10);
        fprintf(plyf, "property uchar green%c", 10);
        fprintf(plyf, "property uchar blue%c", 10);
    }
    fprintf(plyf, "element face %d%c", me->tris->size(), 10);
    fprintf(plyf, "property list uchar int vertex_indices%c", 10);
    fprintf(plyf, "end_header%c", 10);

    for(int i = 0; i < me->pts->size(); i++)
    {
        /*
        if (dobinary==true)
        {
                float pos[3];
                pos[0] = (float)((*me->pts)[i].op.p.x);
                pos[1] = (float)((*me->pts)[i].op.p.y);
                pos[2] = (float)((*me->pts)[i].op.p.z);
                fwrite(&pos[0],sizeof(float),3,plyf);
        }else
        {
                fprintf(plyf,"%f %f %f 128 128 128%c",
                        (float)((*me->pts)[i].op.p.x),
                        (float)((*me->pts)[i].op.p.y),
                        (float)((*me->pts)[i].op.p.z),
                        10
                );
        };
        */
        if(dobinary)
        {
            float pos[3];
            pos[0] = (float)((*me->pts)[i].x);
            pos[1] = (float)((*me->pts)[i].y);
            pos[2] = (float)((*me->pts)[i].z);
            fwrite(&pos[0], sizeof(float), 3, plyf);
        }
        else
        {
            fprintf(plyf, "%f %f %f 128 128 128%c", (float)((*me->pts)[i].x), (float)((*me->pts)[i].y),
                    (float)((*me->pts)[i].z), 10);
        }
    }

    for(int i = 0; i < me->tris->size(); i++)
    {
        if(dobinary)
        {
            unsigned char npts = 3;
            fwrite(&npts, sizeof(unsigned char), 1, plyf);
            int points[3];
            points[0] = (*me->tris)[i].i[0];
            points[1] = (*me->tris)[i].i[1];
            points[2] = (*me->tris)[i].i[2];
            fwrite(&points[0], sizeof(int), 3, plyf);
        }
        else
        {
            fprintf(plyf, "3 %d %d %d", (*me->tris)[i].i[0], (*me->tris)[i].i[1], (*me->tris)[i].i[2]);

            if(i < me->tris->size() - 1)
            {
                fprintf(plyf, "%c", 10);
            }
        }
    }

    fclose(plyf);

    return 0;
}

staticVector<rgb>* getPtsColorsRgb(Mesh* me, staticVector<rgb>* triColors)
{
    staticVector<Color>* ptsColors = new staticVector<Color>(me->pts->size());
    staticVector<float>* nptsColors = new staticVector<float>(me->pts->size());
    ptsColors->resize_with(me->pts->size(), Color(0.0f, 0.0f, 0.0f));
    nptsColors->resize_with(me->pts->size(), 0.0f);

    for(int i = 0; i < me->tris->size(); i++)
    {
        for(int j = 0; j < 3; j++)
        {
            (*ptsColors)[(*me->tris)[i].i[j]].r += (float)(*triColors)[i].r;
            (*ptsColors)[(*me->tris)[i].i[j]].g += (float)(*triColors)[i].g;
            (*ptsColors)[(*me->tris)[i].i[j]].b += (float)(*triColors)[i].b;
            (*nptsColors)[(*me->tris)[i].i[j]] += 1.0f;
        }
    }
    for(int i = 0; i < me->pts->size(); i++)
    {
        (*ptsColors)[i] = (*ptsColors)[i] / (*nptsColors)[i];
    }
    delete nptsColors;

    staticVector<rgb>* ptsColorsRgb = new staticVector<rgb>(me->pts->size());
    for(int i = 0; i < me->pts->size(); i++)
    {
        Color c = (*ptsColors)[i];
        rgb cc;
        cc.r = (unsigned char)(std::max(0.0f, std::min(254.0f, c.r)));
        cc.g = (unsigned char)(std::max(0.0f, std::min(254.0f, c.g)));
        cc.b = (unsigned char)(std::max(0.0f, std::min(254.0f, c.b)));
        ptsColorsRgb->push_back(cc);
    }
    delete ptsColors;

    return ptsColorsRgb;
}

staticVector<rgb>* getTrisColorsRgb(Mesh* me, staticVector<rgb>* ptsColors)
{
    staticVector<rgb>* trisColors = new staticVector<rgb>(me->tris->size());
    trisColors->resize(me->tris->size());
    for(int i = 0; i < me->tris->size(); i++)
    {
        float r = 0.0f;
        float g = 0.0f;
        float b = 0.0f;
        for(int j = 0; j < 3; j++)
        {
            r += (float)(*ptsColors)[(*me->tris)[i].i[j]].r;
            g += (float)(*ptsColors)[(*me->tris)[i].i[j]].g;
            b += (float)(*ptsColors)[(*me->tris)[i].i[j]].b;
        }
        (*trisColors)[i].r = (unsigned char)(r / 3.0f);
        (*trisColors)[i].g = (unsigned char)(g / 3.0f);
        (*trisColors)[i].b = (unsigned char)(b / 3.0f);
    }
    return trisColors;
}

int savePLY(std::string plyFileName, Mesh* me, staticVector<rgb>* triColors, bool diffuse)
{
    staticVector<rgb>* ptsColors = getPtsColorsRgb(me, triColors);

    saveArrayToFile<rgb>(plyFileName + ".trisColors", triColors);
    saveArrayToFile<rgb>(plyFileName + ".ptsColors", ptsColors);

    // printf("Writing to file %s \n",plyFileName.c_str());

    FILE* plyf = nullptr;

    bool dobinary = false;

    if(dobinary)
    {
        plyf = fopen(plyFileName.c_str(), "wb");
    }
    else
    {
        plyf = fopen(plyFileName.c_str(), "wb");
    }

    if(plyf == nullptr)
    {
        printf("Could not open output ply file %s\n", plyFileName.c_str());
        return -1;
    }

    fprintf(plyf, "ply%c", 10);
    if(dobinary)
    {
        fprintf(plyf, "format binary_little_endian 1.0%c", 10);
    }
    else
    {
        fprintf(plyf, "format ascii 1.0%c", 10);
    }
    fprintf(plyf, "comment Generated by multiRecon ( http://cmp.felk.cvut.cz/~jancom1 )%c", 10);
    fprintf(plyf, "element vertex %d%c", me->pts->size(), 10);
    fprintf(plyf, "property float x%c", 10);
    fprintf(plyf, "property float y%c", 10);
    fprintf(plyf, "property float z%c", 10);
    if(diffuse)
    {
        fprintf(plyf, "property uchar diffuse_red%c", 10);
        fprintf(plyf, "property uchar diffuse_green%c", 10);
        fprintf(plyf, "property uchar diffuse_blue%c", 10);
    }
    else
    {
        fprintf(plyf, "property uchar red%c", 10);
        fprintf(plyf, "property uchar green%c", 10);
        fprintf(plyf, "property uchar blue%c", 10);
    }
    fprintf(plyf, "element face %d%c", me->tris->size(), 10);
    fprintf(plyf, "property list uchar int vertex_indices%c", 10);
    fprintf(plyf, "end_header%c", 10);

    for(int i = 0; i < me->pts->size(); i++)
    {
        if(dobinary)
        {
            float pos[3];
            pos[0] = (float)((*me->pts)[i].x);
            pos[1] = (float)((*me->pts)[i].y);
            pos[2] = (float)((*me->pts)[i].z);
            fwrite(&pos[0], sizeof(float), 3, plyf);
            uchar r, g, b;
            r = (*ptsColors)[i].r;
            g = (*ptsColors)[i].g;
            b = (*ptsColors)[i].b;
            fwrite(&r, sizeof(uchar), 1, plyf);
            fwrite(&g, sizeof(uchar), 1, plyf);
            fwrite(&b, sizeof(uchar), 1, plyf);
        }
        else
        {
            fprintf(plyf, "%f %f %f %i %i %i%c", (float)((*me->pts)[i].x), (float)((*me->pts)[i].y),
                    (float)((*me->pts)[i].z), (*ptsColors)[i].r, (*ptsColors)[i].g, (*ptsColors)[i].b, 10);
        }
    }

    for(int i = 0; i < me->tris->size(); i++)
    {
        if(dobinary)
        {
            unsigned char npts = 3;
            fwrite(&npts, sizeof(unsigned char), 1, plyf);
            int points[3];
            points[0] = (*me->tris)[i].i[0];
            points[1] = (*me->tris)[i].i[1];
            points[2] = (*me->tris)[i].i[2];
            fwrite(&points[0], sizeof(int), 3, plyf);
        }
        else
        {
            fprintf(plyf, "3 %d %d %d", (*me->tris)[i].i[0], (*me->tris)[i].i[1], (*me->tris)[i].i[2]);

            if(i < me->tris->size() - 1)
            {
                fprintf(plyf, "%c", 10);
            }
        }
    }

    fclose(plyf);

    delete ptsColors;

    return 0;
}
